{"version":3,"sources":["index.js","tags.json"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nvar _fs = require('fs');\n\nvar _fs2 = _interopRequireDefault(_fs);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar tags = require('./tags.json');\n\n/*\n unsignedByte,\n asciiStrings,\n unsignedShort,\n unsignedLong,\n unsignedRational,\n signedByte,\n undefined,\n signedShort,\n signedLong,\n signedRational,\n singleFloat,\n doubleFloat\n */\nvar bytes = [0, 1, 1, 2, 4, 8, 1, 1, 2, 4, 8, 4, 8];\nvar SOIMarkerLength = 2;\nvar JPEGSOIMarker = 0xffd8;\nvar TIFFINTEL = 0x4949;\nvar TIFFMOTOROLA = 0x4d4d;\nvar APPMarkerLength = 2;\nvar APPMarkerBegin = 0xffe0;\nvar APPMarkerEnd = 0xffef;\nvar data = void 0;\n/**\n * @param buffer {Buffer}\n * @returns {Boolean}\n * @example\n * var content = fs.readFileSync(\"~/Picture/IMG_0911.JPG\");\n * var isImage = isValid(content);\n * console.log(isImage);\n */\nvar isValid = function isValid(buffer) {\n  try {\n    var SOIMarker = buffer.readUInt16BE(0);\n    return SOIMarker === JPEGSOIMarker;\n  } catch (e) {\n    throw new Error('Unsupport file format.');\n  }\n};\n/**\n * @param buffer {Buffer}\n * @returns {Boolean}\n * @example\n */\nvar isTiff = function isTiff(buffer) {\n  try {\n    var SOIMarker = buffer.readUInt16BE(0);\n    return SOIMarker === TIFFINTEL || SOIMarker === TIFFMOTOROLA;\n  } catch (e) {\n    throw new Error('Unsupport file format.');\n  }\n};\n/**\n * @param buffer {Buffer}\n * @returns {Number}\n * @example\n * var content = fs.readFileSync(\"~/Picture/IMG_0911.JPG\");\n * var APPNumber = checkAPPn(content);\n * console.log(APPNumber);\n */\nvar checkAPPn = function checkAPPn(buffer) {\n  try {\n    var APPMarkerTag = buffer.readUInt16BE(0);\n    var isInRange = APPMarkerTag >= APPMarkerBegin && APPMarkerTag <= APPMarkerEnd;\n    return isInRange ? APPMarkerTag - APPMarkerBegin : false;\n  } catch (e) {\n    throw new Error('Invalid APP Tag.');\n  }\n};\n/**\n * @param buffer {Buffer}\n * @param tagCollection {Object}\n * @param order {Boolean}\n * @param offset {Number}\n * @returns {Object}\n * @example\n * var content = fs.readFileSync(\"~/Picture/IMG_0911.JPG\");\n * var exifFragments = IFDHandler(content, 0, true, 8);\n * console.log(exifFragments.value);\n */\nvar IFDHandler = function IFDHandler(buffer, tagCollection, order, offset) {\n  var entriesNumber = order ? buffer.readUInt16BE(0) : buffer.readUInt16LE(0);\n\n  if (entriesNumber === 0) {\n    return {};\n  }\n\n  var entriesNumberLength = 2;\n  var entries = buffer.slice(entriesNumberLength);\n  var entryLength = 12;\n  // let nextIFDPointerBegin = entriesNumberLength + entryLength * entriesNumber;\n  // let bigNextIFDPointer= buffer.readUInt32BE(nextIFDPointerBegin) ;\n  // let littleNextIFDPointer= buffer.readUInt32LE(nextIFDPointerBegin);\n  // let nextIFDPointer = order ?bigNextIFDPointer:littleNextIFDPointer;\n  var exif = {};\n  var entryCount = 0;\n\n  for (entryCount; entryCount < entriesNumber; entryCount += 1) {\n    var entryBegin = entryCount * entryLength;\n    var entry = entries.slice(entryBegin, entryBegin + entryLength);\n    var tagBegin = 0;\n    var tagLength = 2;\n    var dataFormatBegin = tagBegin + tagLength;\n    var dataFormatLength = 2;\n    var componentsBegin = dataFormatBegin + dataFormatLength;\n    var componentsNumberLength = 4;\n    var dataValueBegin = componentsBegin + componentsNumberLength;\n    var dataValueLength = 4;\n    var tagAddress = entry.slice(tagBegin, dataFormatBegin);\n    var tagNumber = order ? tagAddress.toString('hex') : tagAddress.reverse().toString('hex');\n    var tagName = tagCollection[tagNumber];\n    var bigDataFormat = entry.readUInt16BE(dataFormatBegin);\n    var littleDataFormat = entry.readUInt16LE(dataFormatBegin);\n    var dataFormat = order ? bigDataFormat : littleDataFormat;\n    var componentsByte = bytes[dataFormat];\n    var bigComponentsNumber = entry.readUInt32BE(componentsBegin);\n    var littleComponentNumber = entry.readUInt32LE(componentsBegin);\n    var componentsNumber = order ? bigComponentsNumber : littleComponentNumber;\n    var dataLength = componentsNumber * componentsByte;\n    var dataValue = entry.slice(dataValueBegin, dataValueBegin + dataValueLength);\n\n    if (dataLength > 4) {\n      var dataOffset = (order ? dataValue.readUInt32BE(0) : dataValue.readUInt32LE(0)) - offset;\n      dataValue = buffer.slice(dataOffset, dataOffset + dataLength);\n    }\n\n    var tagValue = void 0;\n\n    if (tagName) {\n      switch (dataFormat) {\n        case 1:\n          tagValue = dataValue.readUInt8(0);\n          break;\n        case 2:\n          tagValue = dataValue.toString('ascii').replace(/\\0+$/, '');\n          break;\n        case 3:\n          tagValue = order ? dataValue.readUInt16BE(0) : dataValue.readUInt16LE(0);\n          break;\n        case 4:\n          tagValue = order ? dataValue.readUInt32BE(0) : dataValue.readUInt32LE(0);\n          break;\n        case 5:\n          tagValue = [];\n\n          for (var i = 0; i < dataValue.length; i += 8) {\n            var bigTagValue = dataValue.readUInt32BE(i) / dataValue.readUInt32BE(i + 4);\n            var littleTagValue = dataValue.readUInt32LE(i) / dataValue.readUInt32LE(i + 4);\n            tagValue.push(order ? bigTagValue : littleTagValue);\n          }\n\n          break;\n        case 7:\n          switch (tagName) {\n            case 'ExifVersion':\n              tagValue = dataValue.toString();\n              break;\n            case 'FlashPixVersion':\n              tagValue = dataValue.toString();\n              break;\n            case 'SceneType':\n              tagValue = dataValue.readUInt8(0);\n              break;\n            default:\n              tagValue = '0x' + dataValue.toString('hex', 0, 15);\n              break;\n          }\n          break;\n        case 10:\n          {\n            var bigOrder = dataValue.readInt32BE(0) / dataValue.readInt32BE(4);\n            var littleOrder = dataValue.readInt32LE(0) / dataValue.readInt32LE(4);\n            tagValue = order ? bigOrder : littleOrder;\n            break;\n          }\n        default:\n          tagValue = '0x' + dataValue.toString('hex');\n          break;\n      }\n      exif[tagName] = tagValue;\n    }\n    /*\n     else {\n     console.log(`Unkown Tag [0x${tagNumber}].`);\n     }\n     */\n  }\n  return exif;\n};\n\n/**\n * @param buf {Buffer}\n * @returns {Undefined}\n * @example\n * var content = fs.readFileSync(\"~/Picture/IMG_0911.JPG\");\n * var exifFragments = EXIFHandler(content);\n */\nvar EXIFHandler = function EXIFHandler(buf) {\n  var pad = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n  var buffer = buf;\n\n  if (pad) {\n    buffer = buf.slice(APPMarkerLength);\n    var length = buffer.readUInt16BE(0);\n    buffer = buffer.slice(0, length);\n    var lengthLength = 2;\n    buffer = buffer.slice(lengthLength);\n    var identifierLength = 5;\n    buffer = buffer.slice(identifierLength);\n    var padLength = 1;\n    buffer = buffer.slice(padLength);\n  }\n\n  var byteOrderLength = 2;\n  var byteOrder = buffer.toString('ascii', 0, byteOrderLength) === 'MM';\n  var fortyTwoLength = 2;\n  var fortyTwoEnd = byteOrderLength + fortyTwoLength;\n  var big42 = buffer.readUInt32BE(fortyTwoEnd);\n  var little42 = buffer.readUInt32LE(fortyTwoEnd);\n  var offsetOfIFD = byteOrder ? big42 : little42;\n\n  buffer = buffer.slice(offsetOfIFD);\n\n  if (buffer.length > 0) {\n    data = IFDHandler(buffer, tags.ifd, byteOrder, offsetOfIFD);\n\n    if (data.ExifIFDPointer) {\n      buffer = buffer.slice(data.ExifIFDPointer - offsetOfIFD);\n      data.SubExif = IFDHandler(buffer, tags.ifd, byteOrder, data.ExifIFDPointer);\n    }\n\n    if (data.GPSInfoIFDPointer) {\n      var gps = data.GPSInfoIFDPointer;\n      buffer = buffer.slice(data.ExifIFDPointer ? gps - data.ExifIFDPointer : gps - offsetOfIFD);\n      data.GPSInfo = IFDHandler(buffer, tags.gps, byteOrder, gps);\n    }\n  }\n};\n\n/**\n * @param buffer {Buffer}\n * @returns {Undefined}\n * @example\n * var content = fs.readFileSync(\"~/Picture/IMG_0911.JPG\");\n * var exifFragments = APPnHandler(content);\n */\nvar APPnHandler = function APPnHandler(buffer) {\n  var APPMarkerTag = checkAPPn(buffer);\n\n  if (APPMarkerTag !== false) {\n    // APP0 is 0, and 0==false\n    var length = buffer.readUInt16BE(APPMarkerLength);\n\n    switch (APPMarkerTag) {\n      case 1:\n        // EXIF\n        EXIFHandler(buffer);\n        break;\n      default:\n        APPnHandler(buffer.slice(APPMarkerLength + length));\n        break;\n    }\n  }\n};\n\n/**\n * @param buffer {Buffer}\n * @returns {Object}\n * @example\n */\nvar fromBuffer = function fromBuffer(buffer) {\n  if (!buffer) {\n    throw new Error('buffer not found');\n  }\n\n  data = undefined;\n\n  if (isValid(buffer)) {\n    buffer = buffer.slice(SOIMarkerLength);\n    data = {};\n    APPnHandler(buffer);\n  } else if (isTiff(buffer)) {\n    data = {};\n    EXIFHandler(buffer, false);\n  }\n\n  return data;\n};\n\n/**\n * @param file {String}\n * @returns {Object}\n * @example\n * var exif = sync(\"~/Picture/IMG_1981.JPG\");\n * console.log(exif.createTime);\n */\nvar sync = function sync(file) {\n  if (!file) {\n    throw new Error('File not found');\n  }\n\n  var buffer = _fs2.default.readFileSync(file);\n\n  return fromBuffer(buffer);\n};\n\n/**\n * @param file {String}\n * @param callback {Function}\n * @example\n * async(\"~/Picture/IMG_0707.JPG\", (err, data) => {\n *     if(err) {\n *         console.log(err);\n *     }\n *     if(data) {\n *         console.log(data.ExifOffset.createTime);\n *     }\n * }\n */\nvar async = function async(file, callback) {\n  data = undefined;\n\n  new Promise(function (resolve, reject) {\n    if (!file) {\n      reject(new Error('❓File not found.'));\n    }\n\n    _fs2.default.readFile(file, function (err, buffer) {\n      if (err) {\n        reject(err);\n      } else {\n        try {\n          if (isValid(buffer)) {\n            var buf = buffer.slice(SOIMarkerLength);\n\n            data = {};\n\n            APPnHandler(buf);\n            resolve(data);\n          } else if (isTiff(buffer)) {\n            data = {};\n\n            EXIFHandler(buffer, false);\n            resolve(data);\n          } else {\n            reject(new Error('😱Unsupport file type.'));\n          }\n        } catch (e) {\n          reject(e);\n        }\n      }\n    });\n  }, function (error) {\n    callback(error, undefined);\n  }).then(function (d) {\n    callback(undefined, d);\n  }).catch(function (error) {\n    callback(error, undefined);\n  });\n};\n\nexports.fromBuffer = fromBuffer;\nexports.parse = async;\nexports.parseSync = sync;\n//# sourceMappingURL=index.js.map","module.exports = {\n  \"ifd\": {\n    \"010e\": \"ImageDescription\",\n    \"010f\": \"Make\",\n    \"011a\": \"XResolution\",\n    \"011b\": \"YResolution\",\n    \"011c\": \"PlanarConfiguration\",\n    \"012d\": \"TransferFunction\",\n    \"013b\": \"Artist\",\n    \"013e\": \"WhitePoint\",\n    \"013f\": \"PrimaryChromaticities\",\n    \"0100\": \"ImageWidth\",\n    \"0101\": \"ImageHeight\",\n    \"0102\": \"BitsPerSample\",\n    \"0103\": \"Compression\",\n    \"0106\": \"PhotometricInterpretation\",\n    \"0110\": \"Model\",\n    \"0111\": \"StripOffsets\",\n    \"0112\": \"Orientation\",\n    \"0115\": \"SamplesPerPixel\",\n    \"0116\": \"RowsPerStrip\",\n    \"0117\": \"StripByteCounts\",\n    \"0128\": \"ResolutionUnit\",\n    \"0131\": \"Software\",\n    \"0132\": \"DateTime\",\n    \"0201\": \"JPEGInterchangeFormat\",\n    \"0202\": \"JPEGInterchangeFormatLength\",\n    \"0211\": \"YCbCrCoefficients\",\n    \"0212\": \"YCbCrSubSampling\",\n    \"0213\": \"YCbCrPositioning\",\n    \"0214\": \"ReferenceBlackWhite\",\n    \"829a\": \"ExposureTime\",\n    \"829d\": \"FNumber\",\n    \"920a\": \"FocalLength\",\n    \"927c\": \"MakerNote\",\n    \"8298\": \"Copyright\",\n    \"8769\": \"ExifIFDPointer\",\n    \"8822\": \"ExposureProgram\",\n    \"8824\": \"SpectralSensitivity\",\n    \"8825\": \"GPSInfoIFDPointer\",\n    \"8827\": \"PhotographicSensitivity\",\n    \"8828\": \"OECF\",\n    \"8830\": \"SensitivityType\",\n    \"8831\": \"StandardOutputSensitivity\",\n    \"8832\": \"RecommendedExposureIndex\",\n    \"8833\": \"ISOSpeed\",\n    \"8834\": \"ISOSpeedLatitudeyyy\",\n    \"8835\": \"ISOSpeedLatitudezzz\",\n    \"9000\": \"ExifVersion\",\n    \"9003\": \"DateTimeOriginal\",\n    \"9004\": \"DateTimeDigitized\",\n    \"9101\": \"ComponentsConfiguration\",\n    \"9102\": \"CompressedBitsPerPixel\",\n    \"9201\": \"ShutterSpeedValue\",\n    \"9202\": \"ApertureValue\",\n    \"9203\": \"BrightnessValue\",\n    \"9204\": \"ExposureBiasValue\",\n    \"9205\": \"MaxApertureValue\",\n    \"9206\": \"SubjectDistance\",\n    \"9207\": \"MeteringMode\",\n    \"9208\": \"LightSource\",\n    \"9209\": \"Flash\",\n    \"9214\": \"SubjectArea\",\n    \"9286\": \"UserComment\",\n    \"9290\": \"SubSecTime\",\n    \"9291\": \"SubSecTimeOriginal\",\n    \"9292\": \"SubSecTimeDigitized\",\n    \"a000\": \"FlashpixVersion\",\n    \"a001\": \"ColorSpace\",\n    \"a002\": \"PixelXDimension\",\n    \"a003\": \"PixelYDimension\",\n    \"a004\": \"RelatedSoundFile\",\n    \"a005\": \"InteroperabilityIFDPointer\",\n    \"a20b\": \"FlashEnergy\",\n    \"a20c\": \"SpatialFrequencyResponse\",\n    \"a20e\": \"FocalPlaneXResolution\",\n    \"a20f\": \"FocalPlaneYResolution\",\n    \"a40a\": \"Sharpness\",\n    \"a40b\": \"DeviceSettingDescription\",\n    \"a40c\": \"SubjectDistanceRange\",\n    \"a210\": \"FocalPlaneResolutionUnit\",\n    \"a214\": \"SubjectLocation\",\n    \"a215\": \"ExposureIndex\",\n    \"a217\": \"SensingMethod\",\n    \"a300\": \"FileSource\",\n    \"a301\": \"SceneType\",\n    \"a302\": \"CFAPattern\",\n    \"a401\": \"CustomRendered\",\n    \"a402\": \"ExposureMode\",\n    \"a403\": \"WhiteBalance\",\n    \"a404\": \"DigitalZoomRatio\",\n    \"a405\": \"FocalLengthIn35mmFilm\",\n    \"a406\": \"SceneCaptureType\",\n    \"a407\": \"GainControl\",\n    \"a408\": \"Contrast\",\n    \"a409\": \"Saturation\",\n    \"a420\": \"ImageUniqueID\",\n    \"a430\": \"CameraOwnerName\",\n    \"a431\": \"BodySerialNumber\",\n    \"a432\": \"LensSpecification\",\n    \"a433\": \"LensMake\",\n    \"a434\": \"LensModel\",\n    \"a435\": \"LensSerialNumber\",\n    \"a500\": \"Gamma\"\n  },\n  \"gps\": {\n    \"0000\": \"GPSVersionID\",\n    \"0001\": \"GPSLatitudeRef\",\n    \"0002\": \"GPSLatitude\",\n    \"0003\": \"GPSLongitudeRef\",\n    \"0004\": \"GPSLongitude\",\n    \"0005\": \"GPSAltitudeRef\",\n    \"0006\": \"GPSAltitude\",\n    \"0007\": \"GPSTimeStamp\",\n    \"0008\": \"GPSSatellites\",\n    \"0009\": \"GPSStatus\",\n    \"000a\": \"GPSMeasureMode\",\n    \"000b\": \"GPSDOP\",\n    \"000c\": \"GPSSpeedRef\",\n    \"000d\": \"GPSSpeed\",\n    \"000e\": \"GPSTrackRef\",\n    \"000f\": \"GPSTrack\",\n    \"0010\": \"GPSImgDirectionRef\",\n    \"0011\": \"GPSImgDirection\",\n    \"0012\": \"GPSMapDatum\",\n    \"0013\": \"GPSDestLatitudeRef\",\n    \"0014\": \"GPSDestLatitude\",\n    \"0015\": \"GPSDestLongitudeRef\",\n    \"0016\": \"GPSDestLongitude\",\n    \"0017\": \"GPSDestBearingRef\",\n    \"0018\": \"GPSDestBearing\",\n    \"0019\": \"GPSDestDistanceRef\",\n    \"001a\": \"GPSDestDistance\",\n    \"001b\": \"GPSProcessingMethod\",\n    \"001c\": \"GPSAreaInformation\",\n    \"001d\": \"GPSDateStamp\",\n    \"001e\": \"GPSDifferential\",\n    \"001f\": \"GPSHPositioningError\"\n  }\n}"]}