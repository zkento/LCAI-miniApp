{"version":3,"sources":["index.js","FormData.js","File.js","Blob.js","isFunction.js","blobHelpers.js","isFile.js","isBlob.js","deprecateConstructorEntries.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AGRA,ADGA,ADGA,ADGA;AGRA,ADGA,ADGA,ADGA;AGRA,ADGA,ADGA,ADGA;AGRA,ADGA,ADGA,ADGA,AIZA;ADIA,ADGA,ADGA,ADGA,AIZA;ADIA,ADGA,ADGA,ADGA,AIZA;ADIA,ADGA,ADGA,AIZA,ALeA,AIZA;ADIA,ADGA,ADGA,AIZA,ADGA;ADIA,ADGA,ADGA,AIZA,ADGA;ADIA,ADGA,ADGA,AIZA,ACHA;AHUA,ADGA,ADGA,AIZA,ACHA;AHUA,ADGA,ADGA,AIZA,ACHA;AHUA,ADGA,ADGA,AIZA,AENA,ADGA;AHUA,ADGA,ADGA,AIZA,AENA,ADGA;AHUA,ADGA,ADGA,AIZA,AENA,ADGA;AHUA,ADGA,ADGA,AIZA,AGTA,ADGA,ADGA;AHUA,ADGA,ADGA,AIZA,AGTA,ADGA;AJaA,ADGA,ADGA,AIZA,AGTA,ADGA;AJaA,ADGA,ADGA,AIZA,AGTA,ADGA;AJaA,ADGA,ADGA,AIZA,AGTA;ALgBA,ADGA,ADGA,AIZA,AGTA;ALgBA,ADGA,ADGA,AIZA,AGTA;ALgBA,ADGA,ADGA,AIZA;AFOA,ADGA,ADGA,AIZA;AFOA,ADGA,ADGA,AIZA;AFOA,ADGA,ADGA,AIZA;AFOA,ADGA,ADGA,AIZA;AFOA,ADGA,ADGA,AIZA;AFOA,ADGA,ADGA,AIZA;AFOA,ADGA,ADGA,AIZA;AFOA,ADGA,ADGA,AIZA;AFOA,ADGA,ADGA,AIZA;AFOA,ADGA,ADGA,AIZA;AFOA,ADGA,ADGA,AIZA;AFOA,ADGA,ADGA,AIZA;AFOA,ADGA,ADGA,AIZA;AFOA,ADGA,ADGA,AIZA;AFOA,ADGA,ADGA,AIZA;AFOA,ADGA,ADGA,AIZA;AFOA,ADGA,ADGA,AIZA;AFOA,ADGA,ADGA,AIZA;AFOA,ADGA,ADGA,AIZA;AFOA,ADGA,ADGA,AIZA;AFOA,ADGA,ADGA,AIZA;AFOA,ADGA,ADGA,AIZA;AFOA,ADGA,ADGA,AIZA;AFOA,ADGA,ADGA,AIZA;AFOA,ADGA,ADGA,AIZA;AFOA,ADGA,ADGA,AIZA;AFOA,ADGA,ADGA,AIZA;AFOA,AFMA,AIZA;AFOA,AFMA,AIZA;AFOA,AFMA,AIZA;AFOA,AFMA,AIZA;AFOA,AFMA,AIZA;AFOA,AFMA,AIZA;AFOA,AFMA,AIZA;AFOA,AFMA,AIZA;AFOA,AFMA,AIZA;AFOA,AFMA,AIZA;AFOA,AFMA,AIZA;AFOA,AFMA,AIZA;AFOA,AFMA,AIZA;AFOA,AFMA,AIZA;AFOA,AFMA,AIZA;AFOA,AFMA,AIZA;AFOA,AFMA,AIZA;AFOA,AFMA,AIZA;AFOA,AFMA,AIZA;AFOA,AFMA,AIZA;AFOA,AFMA,AIZA;AFOA,AFMA,AIZA;AFOA,AFMA,AIZA;AFOA,AFMA,AIZA;AFOA,AFMA,AIZA;AFOA,AFMA,AIZA;AFOA,AFMA,AIZA;AFOA,AFMA,AIZA;AFOA,AFMA,AIZA;AFOA,AFMA,AIZA;AFOA,AFMA,AIZA;AFOA,AFMA,AIZA;AFOA,AFMA,AIZA;AFOA,AFMA,AIZA;AFOA,AFMA,AIZA;AFOA,AFMA,AIZA;AFOA,AFMA,AIZA;AFOA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(require(\"./FormData\"), exports);\n__exportStar(require(\"./Blob\"), exports);\n__exportStar(require(\"./File\"), exports);\n","\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _FormData_instances, _FormData_entries, _FormData_setEntry;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FormData = void 0;\nconst util_1 = require(\"util\");\nconst File_1 = require(\"./File\");\nconst isFile_1 = require(\"./isFile\");\nconst isBlob_1 = require(\"./isBlob\");\nconst isFunction_1 = require(\"./isFunction\");\nconst deprecateConstructorEntries_1 = require(\"./deprecateConstructorEntries\");\nclass FormData {\n    constructor(entries) {\n        _FormData_instances.add(this);\n        _FormData_entries.set(this, new Map());\n        if (entries) {\n            (0, deprecateConstructorEntries_1.deprecateConstructorEntries)();\n            entries.forEach(({ name, value, fileName }) => this.append(name, value, fileName));\n        }\n    }\n    static [(_FormData_entries = new WeakMap(), _FormData_instances = new WeakSet(), Symbol.hasInstance)](value) {\n        return Boolean(value\n            && (0, isFunction_1.isFunction)(value.constructor)\n            && value[Symbol.toStringTag] === \"FormData\"\n            && (0, isFunction_1.isFunction)(value.append)\n            && (0, isFunction_1.isFunction)(value.set)\n            && (0, isFunction_1.isFunction)(value.get)\n            && (0, isFunction_1.isFunction)(value.getAll)\n            && (0, isFunction_1.isFunction)(value.has)\n            && (0, isFunction_1.isFunction)(value.delete)\n            && (0, isFunction_1.isFunction)(value.entries)\n            && (0, isFunction_1.isFunction)(value.values)\n            && (0, isFunction_1.isFunction)(value.keys)\n            && (0, isFunction_1.isFunction)(value[Symbol.iterator])\n            && (0, isFunction_1.isFunction)(value.forEach));\n    }\n    append(name, value, fileName) {\n        __classPrivateFieldGet(this, _FormData_instances, \"m\", _FormData_setEntry).call(this, {\n            name,\n            fileName,\n            append: true,\n            rawValue: value,\n            argsLength: arguments.length\n        });\n    }\n    set(name, value, fileName) {\n        __classPrivateFieldGet(this, _FormData_instances, \"m\", _FormData_setEntry).call(this, {\n            name,\n            fileName,\n            append: false,\n            rawValue: value,\n            argsLength: arguments.length\n        });\n    }\n    get(name) {\n        const field = __classPrivateFieldGet(this, _FormData_entries, \"f\").get(String(name));\n        if (!field) {\n            return null;\n        }\n        return field[0];\n    }\n    getAll(name) {\n        const field = __classPrivateFieldGet(this, _FormData_entries, \"f\").get(String(name));\n        if (!field) {\n            return [];\n        }\n        return field.slice();\n    }\n    has(name) {\n        return __classPrivateFieldGet(this, _FormData_entries, \"f\").has(String(name));\n    }\n    delete(name) {\n        __classPrivateFieldGet(this, _FormData_entries, \"f\").delete(String(name));\n    }\n    *keys() {\n        for (const key of __classPrivateFieldGet(this, _FormData_entries, \"f\").keys()) {\n            yield key;\n        }\n    }\n    *entries() {\n        for (const name of this.keys()) {\n            const values = this.getAll(name);\n            for (const value of values) {\n                yield [name, value];\n            }\n        }\n    }\n    *values() {\n        for (const [, value] of this) {\n            yield value;\n        }\n    }\n    [(_FormData_setEntry = function _FormData_setEntry({ name, rawValue, append, fileName, argsLength }) {\n        const methodName = append ? \"append\" : \"set\";\n        if (argsLength < 2) {\n            throw new TypeError(`Failed to execute '${methodName}' on 'FormData': `\n                + `2 arguments required, but only ${argsLength} present.`);\n        }\n        name = String(name);\n        let value;\n        if ((0, isFile_1.isFile)(rawValue)) {\n            value = fileName === undefined\n                ? rawValue\n                : new File_1.File([rawValue], fileName, {\n                    type: rawValue.type,\n                    lastModified: rawValue.lastModified\n                });\n        }\n        else if ((0, isBlob_1.isBlob)(rawValue)) {\n            value = new File_1.File([rawValue], fileName === undefined ? \"blob\" : fileName, {\n                type: rawValue.type\n            });\n        }\n        else if (fileName) {\n            throw new TypeError(`Failed to execute '${methodName}' on 'FormData': `\n                + \"parameter 2 is not of type 'Blob'.\");\n        }\n        else {\n            value = String(rawValue);\n        }\n        const values = __classPrivateFieldGet(this, _FormData_entries, \"f\").get(name);\n        if (!values) {\n            return void __classPrivateFieldGet(this, _FormData_entries, \"f\").set(name, [value]);\n        }\n        if (!append) {\n            return void __classPrivateFieldGet(this, _FormData_entries, \"f\").set(name, [value]);\n        }\n        values.push(value);\n    }, Symbol.iterator)]() {\n        return this.entries();\n    }\n    forEach(callback, thisArg) {\n        for (const [name, value] of this) {\n            callback.call(thisArg, value, name, this);\n        }\n    }\n    get [Symbol.toStringTag]() {\n        return \"FormData\";\n    }\n    [util_1.inspect.custom]() {\n        return this[Symbol.toStringTag];\n    }\n}\nexports.FormData = FormData;\n","\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _File_name, _File_lastModified;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.File = void 0;\nconst Blob_1 = require(\"./Blob\");\nclass File extends Blob_1.Blob {\n    constructor(fileBits, name, options = {}) {\n        super(fileBits, options);\n        _File_name.set(this, void 0);\n        _File_lastModified.set(this, 0);\n        if (arguments.length < 2) {\n            throw new TypeError(\"Failed to construct 'File': 2 arguments required, \"\n                + `but only ${arguments.length} present.`);\n        }\n        __classPrivateFieldSet(this, _File_name, String(name), \"f\");\n        const lastModified = options.lastModified === undefined\n            ? Date.now()\n            : Number(options.lastModified);\n        if (!Number.isNaN(lastModified)) {\n            __classPrivateFieldSet(this, _File_lastModified, lastModified, \"f\");\n        }\n    }\n    static [(_File_name = new WeakMap(), _File_lastModified = new WeakMap(), Symbol.hasInstance)](value) {\n        return value instanceof Blob_1.Blob\n            && value[Symbol.toStringTag] === \"File\"\n            && typeof value.name === \"string\";\n    }\n    get name() {\n        return __classPrivateFieldGet(this, _File_name, \"f\");\n    }\n    get lastModified() {\n        return __classPrivateFieldGet(this, _File_lastModified, \"f\");\n    }\n    get webkitRelativePath() {\n        return \"\";\n    }\n    get [Symbol.toStringTag]() {\n        return \"File\";\n    }\n}\nexports.File = File;\n","\n/*! Based on fetch-blob. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> & David Frank */\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar _Blob_parts, _Blob_type, _Blob_size;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Blob = void 0;\nconst web_streams_polyfill_1 = require(\"web-streams-polyfill\");\nconst isFunction_1 = require(\"./isFunction\");\nconst blobHelpers_1 = require(\"./blobHelpers\");\nclass Blob {\n    constructor(blobParts = [], options = {}) {\n        _Blob_parts.set(this, []);\n        _Blob_type.set(this, \"\");\n        _Blob_size.set(this, 0);\n        options !== null && options !== void 0 ? options : (options = {});\n        if (typeof blobParts !== \"object\" || blobParts === null) {\n            throw new TypeError(\"Failed to construct 'Blob': \"\n                + \"The provided value cannot be converted to a sequence.\");\n        }\n        if (!(0, isFunction_1.isFunction)(blobParts[Symbol.iterator])) {\n            throw new TypeError(\"Failed to construct 'Blob': \"\n                + \"The object must have a callable @@iterator property.\");\n        }\n        if (typeof options !== \"object\" && !(0, isFunction_1.isFunction)(options)) {\n            throw new TypeError(\"Failed to construct 'Blob': parameter 2 cannot convert to dictionary.\");\n        }\n        const encoder = new TextEncoder();\n        for (const raw of blobParts) {\n            let part;\n            if (ArrayBuffer.isView(raw)) {\n                part = new Uint8Array(raw.buffer.slice(raw.byteOffset, raw.byteOffset + raw.byteLength));\n            }\n            else if (raw instanceof ArrayBuffer) {\n                part = new Uint8Array(raw.slice(0));\n            }\n            else if (raw instanceof Blob) {\n                part = raw;\n            }\n            else {\n                part = encoder.encode(String(raw));\n            }\n            __classPrivateFieldSet(this, _Blob_size, __classPrivateFieldGet(this, _Blob_size, \"f\") + (ArrayBuffer.isView(part) ? part.byteLength : part.size), \"f\");\n            __classPrivateFieldGet(this, _Blob_parts, \"f\").push(part);\n        }\n        const type = options.type === undefined ? \"\" : String(options.type);\n        __classPrivateFieldSet(this, _Blob_type, /^[\\x20-\\x7E]*$/.test(type) ? type : \"\", \"f\");\n    }\n    static [(_Blob_parts = new WeakMap(), _Blob_type = new WeakMap(), _Blob_size = new WeakMap(), Symbol.hasInstance)](value) {\n        return Boolean(value\n            && typeof value === \"object\"\n            && (0, isFunction_1.isFunction)(value.constructor)\n            && ((0, isFunction_1.isFunction)(value.stream)\n                || (0, isFunction_1.isFunction)(value.arrayBuffer))\n            && /^(Blob|File)$/.test(value[Symbol.toStringTag]));\n    }\n    get type() {\n        return __classPrivateFieldGet(this, _Blob_type, \"f\");\n    }\n    get size() {\n        return __classPrivateFieldGet(this, _Blob_size, \"f\");\n    }\n    slice(start, end, contentType) {\n        return new Blob((0, blobHelpers_1.sliceBlob)(__classPrivateFieldGet(this, _Blob_parts, \"f\"), this.size, start, end), {\n            type: contentType\n        });\n    }\n    async text() {\n        const decoder = new TextDecoder();\n        let result = \"\";\n        for await (const chunk of (0, blobHelpers_1.consumeBlobParts)(__classPrivateFieldGet(this, _Blob_parts, \"f\"))) {\n            result += decoder.decode(chunk, { stream: true });\n        }\n        result += decoder.decode();\n        return result;\n    }\n    async arrayBuffer() {\n        const view = new Uint8Array(this.size);\n        let offset = 0;\n        for await (const chunk of (0, blobHelpers_1.consumeBlobParts)(__classPrivateFieldGet(this, _Blob_parts, \"f\"))) {\n            view.set(chunk, offset);\n            offset += chunk.length;\n        }\n        return view.buffer;\n    }\n    stream() {\n        const iterator = (0, blobHelpers_1.consumeBlobParts)(__classPrivateFieldGet(this, _Blob_parts, \"f\"), true);\n        return new web_streams_polyfill_1.ReadableStream({\n            async pull(controller) {\n                const { value, done } = await iterator.next();\n                if (done) {\n                    return queueMicrotask(() => controller.close());\n                }\n                controller.enqueue(value);\n            },\n            async cancel() {\n                await iterator.return();\n            }\n        });\n    }\n    get [Symbol.toStringTag]() {\n        return \"Blob\";\n    }\n}\nexports.Blob = Blob;\nObject.defineProperties(Blob.prototype, {\n    type: { enumerable: true },\n    size: { enumerable: true },\n    slice: { enumerable: true },\n    stream: { enumerable: true },\n    text: { enumerable: true },\n    arrayBuffer: { enumerable: true }\n});\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isFunction = void 0;\nconst isFunction = (value) => (typeof value === \"function\");\nexports.isFunction = isFunction;\n","\n/*! Based on fetch-blob. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> & David Frank */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.sliceBlob = exports.consumeBlobParts = void 0;\nconst isFunction_1 = require(\"./isFunction\");\nconst CHUNK_SIZE = 65536;\nasync function* clonePart(part) {\n    const end = part.byteOffset + part.byteLength;\n    let position = part.byteOffset;\n    while (position !== end) {\n        const size = Math.min(end - position, CHUNK_SIZE);\n        const chunk = part.buffer.slice(position, position + size);\n        position += chunk.byteLength;\n        yield new Uint8Array(chunk);\n    }\n}\nasync function* consumeNodeBlob(blob) {\n    let position = 0;\n    while (position !== blob.size) {\n        const chunk = blob.slice(position, Math.min(blob.size, position + CHUNK_SIZE));\n        const buffer = await chunk.arrayBuffer();\n        position += buffer.byteLength;\n        yield new Uint8Array(buffer);\n    }\n}\nasync function* consumeBlobParts(parts, clone = false) {\n    for (const part of parts) {\n        if (ArrayBuffer.isView(part)) {\n            if (clone) {\n                yield* clonePart(part);\n            }\n            else {\n                yield part;\n            }\n        }\n        else if ((0, isFunction_1.isFunction)(part.stream)) {\n            yield* part.stream();\n        }\n        else {\n            yield* consumeNodeBlob(part);\n        }\n    }\n}\nexports.consumeBlobParts = consumeBlobParts;\nfunction* sliceBlob(blobParts, blobSize, start = 0, end) {\n    end !== null && end !== void 0 ? end : (end = blobSize);\n    let relativeStart = start < 0\n        ? Math.max(blobSize + start, 0)\n        : Math.min(start, blobSize);\n    let relativeEnd = end < 0\n        ? Math.max(blobSize + end, 0)\n        : Math.min(end, blobSize);\n    const span = Math.max(relativeEnd - relativeStart, 0);\n    let added = 0;\n    for (const part of blobParts) {\n        if (added >= span) {\n            break;\n        }\n        const partSize = ArrayBuffer.isView(part) ? part.byteLength : part.size;\n        if (relativeStart && partSize <= relativeStart) {\n            relativeStart -= partSize;\n            relativeEnd -= partSize;\n        }\n        else {\n            let chunk;\n            if (ArrayBuffer.isView(part)) {\n                chunk = part.subarray(relativeStart, Math.min(partSize, relativeEnd));\n                added += chunk.byteLength;\n            }\n            else {\n                chunk = part.slice(relativeStart, Math.min(partSize, relativeEnd));\n                added += chunk.size;\n            }\n            relativeEnd -= partSize;\n            relativeStart = 0;\n            yield chunk;\n        }\n    }\n}\nexports.sliceBlob = sliceBlob;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isFile = void 0;\nconst File_1 = require(\"./File\");\nconst isFile = (value) => value instanceof File_1.File;\nexports.isFile = isFile;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isBlob = void 0;\nconst Blob_1 = require(\"./Blob\");\nconst isBlob = (value) => value instanceof Blob_1.Blob;\nexports.isBlob = isBlob;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.deprecateConstructorEntries = void 0;\nconst util_1 = require(\"util\");\nexports.deprecateConstructorEntries = (0, util_1.deprecate)(() => { }, \"Constructor \\\"entries\\\" argument is not spec-compliant \"\n    + \"and will be removed in next major release.\");\n"]}